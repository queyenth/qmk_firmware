#ifdef OLED_ENABLE
#ifdef POMODORO_ENABLE
#include "pomodoro.h"

// TODO
// - Hardcore mode. Block the keyboard while rest is active. Still should be able to unblock somehow but yeah. (by tap dancing twice the main pomodoro key?)
// - There's no need to redraw the clock most of the time, except the timer. So do not redraw!
// - Audio beep for lucky bastards with a beeper.
// - Instead of increasing, read keycodes, like KC_1..KC_0 ? Sounds cool. And blinking while waiting for code. Such UX, such wow. tap dance hold thingy then?
// - Refactor. I'm fine with API (process keycodes, eeprom, render function), but how it works internally, all those timers and stuff... Bad!

// Please, make sure you provided the same pomodoroLogo for animation generation program.
/***** Start of autogenerated part. See: https://git.sr.ht/~qqq/lily58-pomodoro *****/

#define POMODORO_STEPS 100
static const char PROGMEM pomodoroClockAnimations[] = { 16, 128, 48, 247, 80, 1, 17, 192, 49, 1, 49, 6, 18, 192, 49, 24, 50, 1, 19, 192, 49, 32, 50, 6, 20, 64, 50, 8, 51, 1, 20, 128, 21, 64, 49, 64, 50, 16, 21, 128, 51, 8, 22, 128, 50, 32, 23, 128, 51, 16, 54, 1, 24, 128, 55, 1, 49, 128, 51, 32, 52, 16, 56, 1, 57, 1, 52, 32, 57, 2, 58, 2, 58, 4, 59, 4, 59, 8, 60, 8, 60, 16, 61, 16, 60, 32, 61, 32, 60, 64, 61, 64, 57, 128, 58, 128, 60, 128, 61, 128, 62, 128, 81, 1, 89, 1, 90, 1, 92, 1, 93, 1, 89, 2, 90, 2, 92, 2, 93, 2, 91, 4, 92, 4, 93, 4, 89, 4, 90, 4, 92, 8, 89, 8, 90, 8, 91, 8, 92, 16, 90, 16, 91, 16, 89, 16, 91, 32, 92, 96, 91, 64, 90, 64, 91, 128, 90, 128, 122, 1, 123, 1, 122, 2, 81, 2, 121, 2, 121, 4, 120, 12, 119, 24, 118, 16, 117, 16, 118, 32, 116, 16, 117, 32, 116, 32, 115, 48, 114, 96, 113, 96, 80, 2, 112, 96, 111, 96, 110, 48, 109, 48, 108, 48, 106, 16, 107, 24, 106, 8, 105, 8, 106, 4, 76, 32, 104, 4, 105, 6, 104, 2, 75, 32, 76, 16, 79, 2, 104, 1, 72, 128, 103, 1, 70, 128, 71, 128, 72, 64, 75, 16, 76, 8, 71, 64, 74, 16, 70, 64, 75, 8, 70, 32, 71, 32, 74, 8, 76, 4, 78, 2, 70, 16, 71, 16, 75, 4, 71, 8, 72, 8, 74, 4, 77, 2, 70, 8, 73, 4, 70, 4, 71, 4, 72, 4, 75, 2, 76, 2, 72, 2, 73, 2, 74, 2, 70, 2, 71, 2, 70, 1, 71, 1, 72, 1, 73, 1, 74, 1, 75, 1, 76, 1, 77, 1, 78, 1, 79, 1, 39, 128, 40, 128, 40, 64, 44, 128, 41, 64, 45, 128, 40, 32, 43, 64, 40, 16, 41, 32, 42, 32, 44, 64, 41, 16, 43, 32, 42, 16, 45, 64, 41, 8, 42, 8, 43, 16, 44, 32, 6, 128, 39, 1, 40, 2, 41, 4, 7, 128, 40, 1, 41, 2, 42, 4, 43, 8, 44, 16, 45, 32, 47, 128, 7, 64, 8, 128, 41, 1, 42, 2, 43, 4, 8, 64, 9, 192, 42, 1, 43, 2, 44, 8, 45, 16, 10, 128, 44, 4, 46, 32, 43, 1, 44, 2, 45, 8, 44, 1, 45, 4, 46, 16, 47, 64, 45, 2, 46, 8, 45, 1, 47, 32, 46, 2, 46, 1, 47, 16, 47, 1, 15, 128 };
static const uint16_t PROGMEM pomodoroClockAnimationsIndex[] = { 0, 0, 6, 10, 12, 18, 24, 30, 38, 40, 42, 46, 52, 56, 64, 66, 72, 72, 74, 76, 80, 82, 84, 88, 92, 102, 112, 112, 120, 126, 132, 140, 144, 150, 152, 156, 156, 162, 164, 168, 170, 172, 172, 174, 176, 180, 184, 186, 188, 190, 192, 196, 196, 198, 200, 202, 204, 204, 208, 210, 214, 214, 220, 222, 230, 234, 244, 248, 252, 262, 268, 276, 280, 290, 296, 300, 320, 320, 324, 324, 328, 332, 336, 344, 346, 348, 352, 360, 368, 384, 394, 406, 412, 418, 426, 430, 434, 436, 440, 442, 444 };

/***** End of generated part. *****/

static const char PROGMEM numbersFont[] = {
  124, 68,  124, // 0
  72,  124, 64,  // 1
  116, 84,  92,  // 2
  84,  84,  124, // 3
  28,  16,  124, // 4
  92,  84,  116, // 5
  124, 84,  116, // 6
  4,   116, 12,  // 7
  124, 84,  124, // 8
  92,  84,  124, // 9
  0,   40,  0,   // :
  96,  16,  12   // /
};

const char PROGMEM pomodoroLogo[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0,
  0xC0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80,
  0x80, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x80, 0x80,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81,
  0xF3, 0x7F, 0x3F, 0x7F, 0xFF, 0xFF, 0x3B, 0xF1,
  0xF7, 0xFF, 0x3F, 0x39, 0x30, 0x00, 0x01, 0x01,
  0x01, 0x83, 0x86, 0x0C, 0xF8, 0xF0, 0x80, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
  0xCF, 0x07, 0x1F, 0x3F, 0x3F, 0x03, 0x03, 0x03,
  0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x1F, 0xDF, 0xFC, 0x7F, 0x07, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x07, 0x0E, 0x1C, 0x18, 0x30, 0x30, 0x30, 0x60,
  0x60, 0x60, 0x60, 0x30, 0x30, 0x30, 0x30, 0x18,
  0x0C, 0x06, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00
};

const char PROGMEM sessionLogo[] = {
  0, 28, 24, 20, 2, 2, 1, 249,
  249, 129, 130, 130, 4, 12, 48, 192,
  0, 4, 16, 32, 64, 64, 128, 129,
  129, 129, 65, 65, 32, 48, 12, 3,
};

pomodoro_config_t pomodoro_config;

pomodoro_state pomodoroStatus = stopped;
pomodoro_state lastPomodoroStatus = stopped;
size_t pomodoroCount = 1;
uint32_t pomodoroTimer = 0;
uint32_t lastUpdateTimer = 0;
uint32_t pomodoroStarted = 0;
uint32_t lastTimerUpdateTimer = 0; // nice name...

uint8_t pomodoroWork = 25;
uint8_t pomodoroRest = 5;

char pomodoroClock[128] = {0};

char pomodoroTimerString[7]; // MMM:SS\0
char pomodoroSessionString[4]; // %d/%d\0

void eeprom_pomodoro(void)
{
  pomodoro_config.raw = eeconfig_read_user();

  if (pomodoro_config.work) {
    pomodoroWork = pomodoro_config.work;
    pomodoroRest = pomodoro_config.rest;
  }
}

void draw_number(uint8_t x, uint8_t y, char number)
{
  if (number == ':') {
    number = '9' + 1;
  } else if (number == '/') {
    number = '9' + 2;
  }
  number = (number - '0') * POMODORO_NUMBER_FONT_WIDTH;
  
  for (size_t i = 0; i < POMODORO_NUMBER_FONT_WIDTH; i++) {
    uint8_t numberByte = pgm_read_byte(numbersFont+number+i);
    // TODO check if `oled_write_raw_byte` is something we can use.
    for (size_t j = 0; j < POMODORO_NUMBER_FONT_HEIGHT; j++) {
      oled_write_pixel(i+x, j+y, (bool)(numberByte & (1 << j)));
    }
  }
}

void draw_number_string(uint8_t x, uint8_t y, const char *str)
{
  while (*str != '\0') {
    draw_number(x, y, *str++);
    x += POMODORO_NUMBER_FONT_WIDTH + 1; // 1 for space.
  }
}

void draw_session_icon(uint8_t x, uint8_t y, uint8_t width)
{
  // TODO do not assume that the session icon is 32 bytes please
  for (size_t i = 0; i < 32; i++) {
    uint8_t sessionByte = pgm_read_byte(sessionLogo+i);
    uint8_t lineN = i / width;
    uint8_t new_x = x + i - lineN * width;
    uint8_t new_y = y + lineN * 8;
    for (size_t j = 0; j < 8; j++) {
      oled_write_pixel(new_x, new_y + j, (bool)(sessionByte & (1 << j)));
    }
  }
}

uint8_t prev_fill = 0;
void draw_by_animation(uint8_t fill, bool animation)
{
  if (prev_fill == fill) return; // Nothing needs to be changed.

  // Find all the missing animations we need to do.
  uint8_t fill_from = MIN(prev_fill, fill);
  uint8_t fill_to = MAX(prev_fill, fill);
  while (fill_from <= fill_to) {
    uint16_t f = pgm_read_word(pomodoroClockAnimationsIndex+fill_from);
    uint16_t bytesToChange;
    if (fill_from + 1 > POMODORO_STEPS) {
      bytesToChange = sizeof(pomodoroClockAnimations);
    } else {
      bytesToChange = pgm_read_word(pomodoroClockAnimationsIndex+fill_from+1);
    }
    bytesToChange -= f;
    for (size_t b = 0; b < bytesToChange; b+=2) {
      // Would it be cheaper (faster) to read the word and then << 8?
      // Dunno.
      uint8_t animByteN = pgm_read_byte(pomodoroClockAnimations+f+b);
      uint8_t animBitN = pgm_read_byte(pomodoroClockAnimations+f+b+1);
      if (animation) {
	pomodoroClock[animByteN] |= animBitN;
      } else {
	pomodoroClock[animByteN] &= ~animBitN;
      }
    }
    fill_from++;
  }

  prev_fill = fill;
}

void update_clock(void)
{
  // Calculate how much to fill
  uint8_t fill_parts = 0;
  const uint32_t elapsedPomodoro = timer_elapsed32(pomodoroStarted);

  if (pomodoroStatus == work) {
    fill_parts = (double)(POMODORO_STEPS * elapsedPomodoro / POMODORO_WORK);
  } else if (pomodoroStatus == rest) {
    // we fill the rest in a reverse order. Which means we should
    // clear some pixels.
    fill_parts = POMODORO_STEPS - (double)(POMODORO_STEPS * elapsedPomodoro / POMODORO_REST);
  }
  draw_by_animation(fill_parts, pomodoroStatus == work);
}

void render_pomodoro(uint8_t y) {
  oled_write_ln("", false);
  if (pomodoroStatus == stopped) {
    oled_write_ln("RDY", false);
    oled_write_raw_P(pomodoroLogo, sizeof(pomodoroLogo));
    return;
  }
  switch (pomodoroStatus) {
  case work:
    oled_write_ln("WORK", false);
    break;
  case rest:
    oled_write_ln("REST", false);
    break;
  case wait_work:
  case wait_rest:
    oled_write_ln("WAIT", false);
    break;
  default:
    return;
  }
  draw_session_icon (0,  y+20, 16);
  draw_number_string(19, y+24, pomodoroSessionString);
  draw_number_string(8,  y+38, pomodoroTimerString);
  oled_advance_page(false);
  oled_advance_page(false);
  oled_advance_page(false);
  oled_advance_page(false);
  oled_write_raw(pomodoroClock, sizeof(pomodoroClock));
}

void finish_pomodoro(void) {
  oled_clear();
  pomodoroStatus = stopped;
  pomodoroTimer = 0;
  pomodoroStarted = 0;
  pomodoroCount = 1;
  memset(pomodoroClock, 0, sizeof(pomodoroClock)); // clear the clock
  prev_fill = 0;
}

void start_pomodoro(pomodoro_state state) {
  oled_clear();
  pomodoroStatus = state;
  pomodoroTimer = state == work ? (POMODORO_WORK) : (POMODORO_REST);
  pomodoroStarted = timer_read32();
  snprintf(pomodoroSessionString, sizeof(pomodoroSessionString), "%d/%d", pomodoroCount, POMODORO_SESSIONS);
  lastUpdateTimer = 0;
  lastTimerUpdateTimer = 0;
}

void update_pomodoro(uint8_t y) {
  const uint32_t elapsedSinceStart = timer_elapsed32(pomodoroStarted);
  switch (pomodoroStatus) {
  case stopped:
  case wait_work:
  case wait_rest:
    // Do nothing.
    break;
  case work:
    if (lastUpdateTimer == 0 || timer_elapsed32(lastUpdateTimer) >= POMODORO_WORK_UPDATE_CLOCK) {
      update_clock();
      lastUpdateTimer = timer_read32();
    }

    if (elapsedSinceStart >= pomodoroTimer) {
#ifdef POMODORO_MANUAL_REST
      pomodoroStatus = wait_rest;
#else
      start_pomodoro(rest);
#endif
      draw_by_animation(POMODORO_STEPS, pomodoroStatus == work); // draw the whole thing before switching to rest
    }
    break;
  case rest:
    if (lastUpdateTimer == 0 || timer_elapsed32(lastUpdateTimer) >= POMODORO_REST_UPDATE_CLOCK) {
      update_clock();
      lastUpdateTimer = timer_read32();
    }
    if (elapsedSinceStart >= pomodoroTimer) {
      if (pomodoroCount >= POMODORO_SESSIONS) {
        finish_pomodoro();
      } else {
        pomodoroCount++;
	memset(pomodoroClock, 0, sizeof(pomodoroClock));

#ifdef POMODORO_MANUAL_WORK
	pomodoroStatus = wait_work;
#else
	start_pomodoro(work);
#endif
      }
    }
    break;
  }
  if (lastTimerUpdateTimer == 0 || timer_elapsed32(lastTimerUpdateTimer) >= POMODORO_UPDATE_TIMER) {
    uint32_t pomodoroLeft;
    if (pomodoroStatus == wait_work || pomodoroStatus == wait_rest) {
      pomodoroLeft = pomodoroStatus == wait_work ? (POMODORO_WORK) : (POMODORO_REST);
    } else {
      pomodoroLeft = (pomodoroTimer - elapsedSinceStart);
    }
    uint8_t minutes = pomodoroLeft / POMODORO_MINUTE;
    if ((pomodoroStatus == work || pomodoroStatus == rest) && minutes > MAX(pomodoroWork, pomodoroRest)) {
      pomodoroLeft = pomodoroTimer;
      minutes = pomodoroLeft / POMODORO_MINUTE;
    }
    const uint8_t seconds = (pomodoroLeft - (POMODORO_MINUTE * minutes)) / 1000;
    snprintf(pomodoroTimerString, sizeof(pomodoroTimerString), "%02d:%02d", minutes, seconds);
    lastTimerUpdateTimer = timer_elapsed32(lastTimerUpdateTimer);
  }
  render_pomodoro(y);
}

bool process_pomodoro(uint16_t startKeycode, uint16_t incKeycode, uint16_t keycode, keyrecord_t *record)
{
  if (keycode == startKeycode) {
    if (record->event.pressed) {
      if (pomodoroStatus == work || pomodoroStatus == rest) {
        finish_pomodoro();
      } else if (pomodoroStatus == wait_rest) {
        start_pomodoro(rest);
      } else { // also if pomodoroStatus == wait_work.
        start_pomodoro(work);
      }
    }
    return false;
  } else if (keycode == incKeycode) {
    if (record->event.pressed) {
      if (pomodoroStatus == work || pomodoroStatus == wait_work) {
	if (pomodoroWork + POMODORO_STEP_WORK > POMODORO_MAX_WORK) {
	  pomodoroWork = POMODORO_MIN_WORK;
	} else {
	  pomodoroWork += POMODORO_STEP_WORK;
	}
	pomodoro_config.work = pomodoroWork;
	eeconfig_update_user(pomodoro_config.raw);
        // Restart pomodoro work if currently is working
	if (pomodoroStatus == work) {
	  start_pomodoro(work);
	}
      } else if (pomodoroStatus == rest || pomodoroStatus == wait_rest) {
	if (pomodoroRest + POMODORO_STEP_REST > POMODORO_MAX_REST) {
	  pomodoroRest = POMODORO_MIN_REST;
	} else {
	  pomodoroRest += POMODORO_STEP_REST;
	}
	pomodoro_config.rest = pomodoroRest;
	eeconfig_update_user(pomodoro_config.raw);
        // Restart rest if currently is resting
	if (pomodoroStatus == rest) {
	  start_pomodoro(rest);
	}
      }
    }
    return false;
  }
  
  return true;
}
#endif
#endif
